syntax = "proto3";
package cosmos.tx.v1beta1;

import "cosmos/base/v1beta1/coin_simple.proto";

// Tx is the standard type used for broadcasting transactions
message Tx {
  // body is the processable content of the transaction
  TxBody body = 1;
  
  // auth_info is the authorization related content of the transaction
  AuthInfo auth_info = 2;
  
  // signatures is a list of signatures that matches the length and order of
  // AuthInfo's signer_infos to allow connecting signature meta information like
  // public key and signing mode by position.
  repeated bytes signatures = 3;
}

// TxRaw is a variant of Tx that pins the signer's exact binary representation
message TxRaw {
  // body_bytes is a protobuf serialization of a TxBody that matches the
  // representation in SignDoc.
  bytes body_bytes = 1;
  
  // auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  // representation in SignDoc.
  bytes auth_info_bytes = 2;
  
  // signatures is a list of signatures that matches the length and order of
  // AuthInfo's signer_infos to allow connecting signature meta information like
  // public key and signing mode by position.
  repeated bytes signatures = 3;
}

// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT
message SignDoc {
  // body_bytes is protobuf serialization of a TxBody that matches the
  // representation in TxRaw.
  bytes body_bytes = 1;
  
  // auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  // representation in TxRaw.
  bytes auth_info_bytes = 2;
  
  // chain_id is the unique identifier of the chain this transaction targets.
  // It prevents signed transactions from being used on another chain by an
  // attacker
  string chain_id = 3;
  
  // account_number is the account number of the account in state
  uint64 account_number = 4;
}

// TxBody is the body of a transaction that all signers sign over
message TxBody {
  // messages is a list of messages to be executed. The required signers of
  // those messages define the number and order of elements in AuthInfo's
  // signer_infos and Tx's signatures. Each required signer address is added to
  // the list only the first time it occurs.
  // By convention, the first required signer (usually from the first message)
  // is referred to as the primary signer and pays the fee for the whole
  // transaction.
  repeated Any messages = 1;
  
  // memo is any arbitrary note/comment to be added to the transaction.
  string memo = 2;
  
  // timeout is the block height after which this transaction will not
  // be processed by the chain
  uint64 timeout_height = 3;
  
  // extension_options are arbitrary options that can be added by chains
  // when the default options are not sufficient. If any of these are present
  // and can't be handled, the transaction will be rejected
  repeated Any extension_options = 1023;
  
  // extension_options are arbitrary options that can be added by chains
  // when the default options are not sufficient. If any of these are present
  // and can't be handled, they will be ignored
  repeated Any non_critical_extension_options = 2047;
}

// AuthInfo describes the fee and signer modes that are used to sign a
// transaction.
message AuthInfo {
  // signer_infos defines the signing modes for the required signers. The number
  // and order of elements must match the required signers from TxBody's
  // messages. The first element is the primary signer and the one which pays
  // the fee.
  repeated SignerInfo signer_infos = 1;
  
  // Fee is the fee and gas limit for the transaction. The first signer is the
  // primary signer and the one which pays the fee. The fee can be calculated
  // based on the cost of evaluating the body and doing signature verification
  // of the signers. This can be estimated via simulation.
  Fee fee = 2;
}

// SignerInfo describes the public key and signing mode of a single top-level
// signer.
message SignerInfo {
  // public_key is the public key of the signer. It is optional for accounts
  // that already exist in state. If unset, the verifier can use the required \
  // signer address for this position and lookup the public key.
  Any public_key = 1;
  
  // mode_info describes the signing mode of the signer and is a nested
  // structure to support nested multisig pubkey's
  ModeInfo mode_info = 2;
  
  // sequence is the sequence of the account, which describes the
  // number of committed transactions signed by a given address. It is used to
  // prevent replay attacks.
  uint64 sequence = 3;
}

// ModeInfo describes the signing mode of a single or nested multisig signer.
message ModeInfo {
  // sum is the oneof that specifies whether this represents a single or nested
  // multisig signer
  oneof sum {
    // single represents a single signer
    Single single = 1;
    
    // multi represents a nested multisig signer
    Multi multi = 2;
  }
  
  // Single is the mode info for a single signer. It is structured as a message
  // to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
  // future
  message Single {
    // mode is the signing mode of the single signer
    SignMode mode = 1;
  }
  
  // Multi is the mode info for a multisig public key
  message Multi {
    // bitarray specifies which keys within the multisig are signing
    CompactBitArray bitarray = 1;
    
    // mode_infos is the corresponding modes of the signers of the multisig
    // which could include nested multisig public keys
    repeated ModeInfo mode_infos = 2;
  }
}

// SignMode represents a signing mode with its own security guarantees.
enum SignMode {
  // SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
  // rejected
  SIGN_MODE_UNSPECIFIED = 0;
  
  // SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
  // verified with raw bytes from Tx
  SIGN_MODE_DIRECT = 1;
  
  // SIGN_MODE_TEXTUAL is a future signing mode that will verify some
  // human-readable textual representation on top of the binary representation
  // from SIGN_MODE_DIRECT
  SIGN_MODE_TEXTUAL = 2;
  
  // SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
  // Amino JSON and will be removed in the future
  SIGN_MODE_LEGACY_AMINO_JSON = 127;
  
  // SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
  // SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
  //
  // Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
  // but is not implemented on the SDK by default. To enable EIP-191, you need
  // to pass a custom `TxConfig` that has an implementation of
  // `SignModeHandler` for EIP-191. The SDK may decide to fully support
  // EIP-191 in the future.
  //
  // Since: cosmos-sdk 0.45.2
  SIGN_MODE_EIP_191 = 191;
}

// Fee includes the amount of coins paid in fees and the maximum
// gas to be used by the transaction. The ratio yields an effective "gasprice",
// which must be above some miminum to be accepted into the mempool.
message Fee {
  // amount is the amount of coins to be paid as a fee
  repeated cosmos.base.v1beta1.Coin amount = 1;
  
  // gas_limit is the maximum gas that can be used in transaction processing
  // before an out of gas error occurs
  uint64 gas_limit = 2;
  
  // if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
  // the payer must be a tx signer (and thus have signed this field in AuthInfo).
  // setting this field does *not* change the ordering of required signers for the transaction.
  string payer = 3;
  
  // if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
  // to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
  // not support fee grants, this will fail
  string granter = 4;
}

// CompactBitArray is an implementation of a space efficient bit array.
message CompactBitArray {
  uint32 extra_bits_stored = 1;
  bytes elems = 2;
}

// Any contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
message Any {
  // A URL/resource name that uniquely identifies the type of the serialized
  // protocol buffer message.
  string type_url = 1;
  
  // Must be a valid serialized protocol buffer of the above specified type.
  bytes value = 2;
}